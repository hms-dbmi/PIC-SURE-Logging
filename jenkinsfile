pipeline {
  agent any

  parameters {
    string(name: 'DOCKER_REGISTRY', description: 'Docker registry URL (e.g., ECR URL)', defaultValue: 'hms-dbmi')
    string(name: 'REPOSITORY_NAME', description: 'Docker repository name', defaultValue: 'pic-sure-logging')
    choice(name: 'DEPLOY_METHOD', description: 'Deployment method', choices: ['docker', 's3', 'none'])
    string(name: 'TARGET_STACK', description: 'Target stack for deployment (required for s3 deploy)', defaultValue: '')
    string(name: 'STACK_S3_BUCKET', description: 'S3 bucket for image upload (required for s3 deploy)', defaultValue: '')
  }

  stages {
    stage('init') {
      steps {
        script {
          env.GIT_BRANCH_SHORT = sh(script: 'echo "${GIT_BRANCH}" | awk -F/ \'{print $NF}\'', returnStdout: true).trim()
          env.GIT_COMMIT_SHORT = sh(script: 'echo "${GIT_COMMIT}" | cut -c1-7', returnStdout: true).trim()
          env.IMAGE_TAG        = "${env.GIT_BRANCH_SHORT}_${env.GIT_COMMIT_SHORT}"
          env.LATEST_TAG       = params.DEPLOY_METHOD == 's3' ? 'latest' : 'LATEST'
          env.IMAGE_NAME       = "${params.DOCKER_REGISTRY}/${params.REPOSITORY_NAME}"
        }
      }
    }

    stage('build jar (docker run)') {
      steps {
        sh '''
          set -euo pipefail

          # DOCKER_CONFIG_DIR is set in all-in-one but not BDC.
          # In all-in-one the host path differs from the container path.
          # In BDC the workspace mount is an identity map (host == container).
          if [ -n "${DOCKER_CONFIG_DIR:-}" ]; then
            MOUNT_PATH="$DOCKER_CONFIG_DIR/jenkins_home/workspace/$JOB_NAME"
          else
            MOUNT_PATH="$WORKSPACE"
          fi

          docker run --rm \
            -v "$MOUNT_PATH/:/app:Z" \
            -v maven_m2_cache:/root/.m2 \
            -w /app \
            maven:3.9.9-amazoncorretto-24 \
            sh -lc "mvn clean install -B -T 1C -DskipTests"

          ls -lah target || true
        '''
      }
    }

    stage('build image') {
      steps {
        sh '''
          set -euo pipefail

          PROXY_ARGS=""
          if [ -n "${http_proxy:-}" ]; then
            PROXY_ARGS="--build-arg http_proxy=$http_proxy --build-arg https_proxy=$http_proxy --build-arg HTTP_PROXY=$http_proxy --build-arg HTTPS_PROXY=$http_proxy"
          fi
          if [ -n "${no_proxy:-}" ]; then
            PROXY_ARGS="$PROXY_ARGS --build-arg no_proxy=$no_proxy --build-arg NO_PROXY=$no_proxy"
          fi

          docker build $PROXY_ARGS -t "${IMAGE_NAME}:${IMAGE_TAG}" .
          docker tag "${IMAGE_NAME}:${IMAGE_TAG}" "${IMAGE_NAME}:${LATEST_TAG}"
        '''
      }
    }

    stage('deploy') {
      steps {
        script {
          if (params.DEPLOY_METHOD == 'docker') {
            sh '''
              set +e
              docker stop pic-sure-logging
              docker rm pic-sure-logging
              set -e

              CONFIG_DIR="${DOCKER_CONFIG_DIR:-/usr/local/docker-config}/logging"

              docker run --name=pic-sure-logging --restart always \
                --network=picsure \
                --env-file "$CONFIG_DIR/logging.env" \
                -v "$CONFIG_DIR/logs":/app/logs \
                -d "${IMAGE_NAME}:${IMAGE_TAG}"
            '''
          } else if (params.DEPLOY_METHOD == 's3') {
            sh '''
              docker save "${IMAGE_NAME}:${LATEST_TAG}" | gzip > pic-sure-logging.tar.gz
              aws s3 --sse=AES256 cp pic-sure-logging.tar.gz "s3://${stack_s3_bucket}/${TARGET_STACK}/containers/pic-sure-logging.tar.gz"
            '''
          } else {
            echo "Deployment skipped."
          }
        }
      }
    }
  }
}
